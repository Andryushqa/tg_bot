# В google colab добавить: !pip install pyTelegramBotAPI
# Чтобы добавить новое слово — нужно его прописать в объект DEFINITOINS на 13 строчке
# Важно все новые аббривиатуры в коде писать только с маленьких букв
# Пользователь в телеграм может писать и с большой и с маленькой — код всегда приводит к строчным

from telebot import TeleBot, types

bot = TeleBot(token='5760342694:AAHau-XZ1RgVC-9wYmKc2zwHs-_xBrBEpqE', parse_mode='html') # создание бота

# словарь с определениями и аббревиатурами, которые знает бот
# в формате:
# 'ключевая фраза': 'соответствующее ей определение'
DEFINITOINS = {
    'регресс': 'Проверить что новый функционал не сломал существующий',
    'тестирование': 'это поиск разницы между ожидаемым и фактическим результатом',
    'тестировщик': 'это специалист, который проверяет работу ПО, проводит оценку качества продукта, наличие дефектов и соответствие фактической работы ПО к заявленным требованиям, снижает риски выпуска некачественного ПО',
    'qa': 'обеспечение качества - это проверка и оценка качества продукта согласно документации и негативным кейсам, а также построение процесса тестирования',
    'qc': 'контроль качества - это проверка и оценка качества продукта согласно документации и негативным кейсам',
    'клиент': 'часть цифрового продукта, с которой взаимодействует пользователь. Обычно это сайт или мобильное приложение',
    'бэкэнд ': 'это внутренняя, скрытая от пользователя часть цифрового продукта, которая находится на сервере. (в разговорной речи бэк, бэкэнд, сервер)',
    'http': 'это протокол, созданный для передачи данных от клиента к бэкэнду (бэкэнд с бэкэндом тоже могут обмениваться данными по HTTP)',
    'квери': 'это часть урла, в которой можно передать с клиента на бэкэнд дополнительную информацию. Не используют для передачи чувствительных данных (пароли, персональные данные). Квери начинаются со знака ?, а если в урле несколько квери, то каждый следующий разделяется &. Имеют ограничение по длине, поскольку максимальная длина урла 2048 символов.',
    'rest': 'архитектурный стиль, правила которого желательно соблюдать, поддерживает различные форматы (JSON, XML, текстовые форматы), работает только по протоколу HTTP (или HTTPS), может быть закэширован.',
    'soap': 'это протокол, используя который важно строго соблюдать все его правила, поддерживает только XML, может работать с различными протоколами (HTTP, SMTP, FTP).',
    'api': 'это интерфейс, обычно реализованный в виде HTTP методов, с помощью которого может взаимодействовать клиент и сервер (или сервер и сервер).',
    'смоук': 'тестирование самого критического функционала, как правило, на 5 минут.',
    'класс эквивалентности': 'Это техника тест-дизайна, в которой мы все вводные данные делим на классы по следующему признаку: любое значение из этого класса приводит к одинаковому поведению системы.',
    'граничные значения': 'Из всех возможных значений мы проверяем минимальное (+/- 1), максимальное (+/- 1) и значения на стыке классов эквивалентности.',
    'тест-кейс': 'это чёткое описание действий, которые необходимо выполнить для проверки функционала.',
    'tms': 'Это системы управления тестированием. Домик, где хранятся тест-кейсы. К примеру - TestRail, Test IT, Qase io, Zephyr, Яндекс.пальма, Allure , Azure.',
    'Test Suite': 'Это наборы тест-кейсов, объединенные по какому-то признаку. Например, что они относятся к одному модулю, функциональности, приоритету или одному типу тестирования (например, тестирование личного кабинета).',
    'Slave': 'Это реплика - копия основной базы данных. Предназначена для снижения нагрузки на мастер и обрабатывает запросы только для чтения.',
    'scrum': 'это подход, в котором: Делимся на команды до 10 человек, делим работу на отрезки времени (спринты) по 1-2 недели, в начале каждого спринта — планирование, каждый день встречи на 5-10 минут — стендапы (или дейлики), в конце спринта обсуждаем итоги и проблемы — ретро, раз в два-три спринта устраиваем встречу между всеми командами и делимся результатами — демо, может быть у кого-то роль «Скрам мастер»',
    'kanban': 'подход построенный на управлении проектом в виде доски с карточками и столбиками-статусами',
    'дейли': 'ежедневные созвоны, где вся команда кратко рассказывает, кто что делал вчера, и что будет делать сегодня. Не более 15 минут.',
    'ретро': 'ретроспектива - встреча в конце спринта, для обсуждения результатов. На встрече отвечают на вопросы: все ли вы там делали правильно? Какие ошибки допускали? Что получалось удачно, а что плохо?',
    'планирование': 'встреча, на которой обсуждаем, что будем делать в ближайшем спринте.',
    'демо': 'раз в квартал команды делятся успехами и новостями о своей работе (своём проекте).',
    'agile': 'это гибкая методология разработки. Работающий продукт важнее исчерпывающей документации. Готовность к изменениям важнее следования первоначальному плану',
    'операторы SQL': 'CREATE, DELETE, INSERT, SELECT, FROM, WHERE, AND, NOT, ORDER BY, HAVING, JOIN, GROUP BY',
    'html': 'это язык разметки сайтов',
    'css': 'язык внешнего вида, стиля элементов сайта.',
    'селектор': 'Это механизм поиска html элемента',
    'charles': 'Программа для перехватывания и просмотра HTTP трафика (запросов и ответов).',
    'html': 'язык разметки сайтов',
    'ci/cd': 'это философия разработки и набор практик, при которых в код вносятся небольшие изменения с частыми коммитами и постоянным деплоем в окружение.',
    'figma': 'Инструмент для работы дизайнеров',
    'хот-фикс': 'Это релиз, в рамках которого выкатили только правку критичного бага',
    'ретест': 'Это повторное тестирование ранее найденных багов, после исправления их разработчиком.',
    'adb': 'ADB (Android Debug Bridge) - это линуксовый инструмент для тестирования мобильных приложений.',
    'симулятор': 'имитирует только операционную систему.',
    'эмулятор': 'имитирует как операционную систему, так и техническое оснащение.',
    'вечер в хату': 'часик в радость, чифирь в сладость',
    'новое слово': 'тут его определение',
    'новое слово': 'тут его определение',


}

# обработчик команды '/start'
@bot.message_handler(commands=['start'])
def start_command_handler(message: types.Message):
    # отправляем ответ на команду '/start'
    bot.send_message(
        chat_id=message.chat.id, # id чата, в который необходимо направить сообщение
        text='Привет! Я помогу тебе расшифровать сложные аббревиатуры и термины 🤓\nВведи интересующий термин, например, регресс', # текст сообщения
    )

# обработчик всех остальных сообщений
@bot.message_handler()
def message_handler(message: types.Message):
    # пробуем найти ключевую фразу в словаре
    definition = DEFINITOINS.get(
        message.text.lower(), # приводим текст сообщения к нижнему регистру
    )
    # если фразы нет в словаре, то переменная definition будет иметь значение None
    # проверяем это условие
    if definition is None:
        # если ключевая фраза не была найдена в словаре
        # отправляем ответ
        bot.send_message(
            chat_id=message.chat.id,
            text='😋 Извини, но я пока не знаю такого определения',
        )
        # выходим из функции
        return
    
    # если ключевая фраза была найдена, формируем текст сообщения и отправляем его
    # если перед строкой поставить букву f, то в фигурных скобках {} можно использовать переменные :)
    bot.send_message(
        chat_id=message.chat.id,
        text=f'Определение:\n<code>{definition}</code>',
    )

    bot.send_message(
        chat_id=message.chat.id,
        text=f'Жду следующий термин',
    )


# главная функция программы
def main():
    # запускаем нашего бота
    bot.infinity_polling()


if __name__ == '__main__':
    main()
